
                           РАБОТА СО СЛОВАРЯМИ
# dict - неупорядоченная коллекция произвольных объектов с доступом по ключу.
# иногда называют асоциативным массивом, так как в пайтом нет массивов, то можно назвать 
# асоциативный список.

a={'moskva','piter','penza'}
# создадим ассоциации по ключу и свяжем город с его индексом.
'moskva' - 495,
'piter'-812,
'penza'-8412

# Создадим словать:
# _____________________________________________________________
# 1 Способ: - составляем его полностью в ручную.
a={
    # key:value
    'moskva':495,
    'piter':812,
    'penza':8412
}
print(a) # {'moskva': 495, 'piter': 812, 'penza': 8412}
# _____________________________________________________________

# 2 Способ: - с использованием функции dict, передаем ей ключ и значение в круглых скобках:
# такой способ применяется только ести в качестве ключа используются строковые значения, для цифр выдаст ошибку
r=dict(moskva=495,piter=812,penza=8412)
print(r) # {'moskva': 495, 'piter': 812, 'penza': 8412}  автоматически преобразует в словать (ключ-значение)
# _____________________________________________________________

# 3 способ, тоже с использованием функции dict, для этого необходимо создать вложеный список:
# типа:
a=[('moskva',495),('piter',812),('penza',8412)]
t=dict(a)
print(t) #{'moskva': 495, 'piter': 812, 'penza': 8412}

# _____________________________________________________________
# # 4 способ:
a=dict.fromkeys(['a','b','c'])
print(a) #{'a': None, 'b': None, 'c': None} -c пустыми значениями
a=dict.fromkeys(['a','b','c'],100)
print(a) #{'a': 100, 'b': 100, 'c': 100} -у всех ключей значени одинаковые.
# _____________________________________________________________

# ПУСТОЙ СЛОВАРЬ СОЗДАТЬ
# 1 Способ
v={}
print(v) # {}
print(v,type(v)) # {} <class 'dict'>
# 2 Способ
v=dict()
print(v) #{}

# _____________________________________________________________
# РАБОТА СО СЛОВАРЕМ.
# _____________________________________________________________
# ключами могут быть любые значения
a={
    # key:value
    1:'one', # значением может быть числом 34, слова, список [1,2,3]
    2:'two', # Ключем не может быть изменяемый тип объекта, такой как список и т.д.
    3:'three',
    #4:[1,2,3]
}
print(a) #{1: 'one', 2: 'two', 3: 'three'}
# _____________________________________________________________
# ОБРАЩЕНИЕ К СЛОВАРЮ. 
# Обращаться можно не по значению а только по ключу.
print(a[2]) # two
print(a[4]) # [1, 2, 3]
print(a[0]) # такого ключа в списке нет и получим ошибку - KeyError: 0

# __________________________ДОБАВИТЬ ЗНАЧЕНИЯ В СЛОВАРЬ___________________________________
a[4]='four'
print(a) # {1: 'one', 2: 'two', 3: 'three', 4: 'four'}
# для изменения значения ключу присваивается новое значение. a[4]='новое значение'


# _____________________ПРИМЕР РАБОТЫ СО СЛОВАРЕМ________________________________________
создадим строку с данными
person={} # Пустой словарь персон-человек
a='IVANOV IVAN IVANOVICH Samara SGU 2 4 5 6 7 8'
# Разбиваем строку по пробелам с использованием метода .split()
a=a.split()
# print(a) # Получаем такой список ['IVANOV', 'IVAN', 'IVANOVICH', 'Samara', 'SGU', '2', '4', '5', '6', '7', '8']
# Заполним словарь данными этима и создадим под эти значения ключи
# создаем значения ключа и передаем значения из строки по индексу.
person['lastName']=a[0]
print(person) # {'lastName': 'IVANOV'}
person['firstName']=a[1]
print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN'}
person['surname']=a[2]
print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'surname': 'IVANOVICH'}
person['city']=a[3]
print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'surname': 'IVANOVICH', 'city': 'Samara'}
person['university']=a[4]
print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'surname': 'IVANOVICH', 'city': 'Samara', 'university': 'SGU'}
# так как оценки должны быть значениями типа int их необходимо явно преобразовать.
# для этого создадим для начала пустой список для ключа оценки
person['marks']=[]
print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'surname': 'IVANOVICH', 'city': 'Samara', 'university': 'SGU', 'marks': []}
 # пробежимся по всем элементам строки  а только с 5 значения и до конца строки.
for i in a[5:]:
    # будем оценки добавлять в пустой список приобразовав значения в целый тип
    person['marks'].append(int(i))
print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'surname': 'IVANOVICH', 'city': 'Samara', 'university': 'SGU', 'marks': [2, 4, 5, 6, 7, 8]}

# ____________УДАЛЕНИЕ ЭЛЕМАЕТОВ ИЗ СЛОВАРЯ ____________________
a={
    # key:value
    1:'one', # значением может быть числом 34, слова, список [1,2,3]
    2:'two', # Ключем не может быть изменяемый тип объекта, такой как список и т.д.
    3:'three',
    4:[1,2,3]
}
print(a) # до удаления {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
# для удаления элемента со словаря воспользуемся функцией del и передадим ей значения ключа который ходим удалить.
del a[4]
print(a) # {1: 'one', 2: 'two', 3: 'three'}
# если попробовать удалить ключ которого нет  в словаре мы получим ОШИБКУ
del a[5] # KeyError: 5


# _____________Функции применяемые к словарю____________
len(объект) - определить длину словаря.
print(len(a))# возвращает количество пар - key-value - 4
#  Проверяем имеется ли данный ключ в словаре
print(1 in a) # True
print(1 in a, 5 in a) # True False
print(1 in a, 5 in a, 7 not in a) # True False True, - 7 not in a меняет значения на противоположное.

# ПЕРЕД ВЫПОЛНЕНИЕМ РАБОТ С КЛЮЧЕМ НЕОБХОДИМО ПРОВЕРИТЬ НАЛИЧИЕ ЭТОГО КЛЮЧА В СЛОВАРЕ ЧТО БЫ НЕ ВЫДАЛО ОШИБКУ.
if 5 in a:
    print(a[5]) #если 5 есть в словаре, мы ее распечатаем
else: # Если ее нет в словаре, можно при необходимости ее создать
    a[5]='five'
print(a) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3], 5: 'five'}

# ТАК КАК словарь является коллекцией, то его можно обойти в цикле for
for i in a:
    print(i) # В i будет присваиваться значения ключа
    # #   1
    #     2
    #     3
    #     4
# Зная i можно обратится и ко значению этого ключа
for key in a:
    print(key,a[key]) 
    # 1 one
    # 2 two
    # 3 three
    # 4 [1, 2, 3]


# ________________МЕТОДЫ ДЛЯ РАБОТЫ СО СЛОВАРЕМ__________
# __1___   a.clear() - очищает словарь весь
d={
    # key:value
    1:'one', # значением может быть числом 34, слова, список [1,2,3]
    2:'two', # Ключем не может быть изменяемый тип объекта, такой как список и т.д.
    3:'three',
    4:[1,2,3]
}
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
d.clear()
print(d) #{}
d1= d.clear() # None
# print(d1) # None
print(d)
#____2______ метод  get - переводится как получить
#принимает в качестве значения номер ключа и возвращает его значения.
r=d.get(1)
print(r) # one
print(d.get(2)) # two
print(d.get(5)) # Если такого ключа нет то get вернет - None или можно изменить это значение если передать get второй параметр
print(d.get(5,'No sush key')) # No sush key - такого ключа нет
print(d.get(5,100)) # 100
print(d.get(5,[1,2,3])) # [1, 2, 3]

#____3______ метод  setdefault() - принимает одно обязательное значение - key и возвращает его значение
print(d.setdefault(3)) # three
print(d.setdefault(5)) # такого ключа в словаре нет и поэтому вернется значение none но при этом он в словарь добавит этот ключ и присвоит ему значение None
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3], 5: None}
print(d.setdefault(6))
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3], 5: None, 6: None}
# Мы можем передать через запятую второй параметр и он будет присвоен если его нет в качестве значения
print(d.setdefault(7,'seven'))
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3], 5: None, 6: None, 7: 'seven'}
# Если обращатся к ключу который есть, то онпросто вернет значение и ничего не произойдет и второй параметр если передать ничего не меняет
print(d.setdefault(4,'seven')) # [1, 2, 3]
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}

#____3______ метод  pop() - принимает значение ключа и возвращает это значение по ключу, но при этом удалит его из словаря.
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
a=d.pop(1)
print(a) # one
print(d) #{2: 'two', 3: 'three', 4: [1, 2, 3]}
print(d.pop()) # Вызов без параметра выдаст ошибку
print(d.pop(5)) # Если передать значение ключа которого нет, то тоже получим ошибку только другого типа.
# ЖЕЛАТЕЛЬНО ПРОВЕРЯТЬ ОБЯЗАТЕЛЬНО НА НАЛИЧИЕ ТАКОГО КЛЮЧА В СЛОВАРЕ ПЕРЕД УДАЛЕНИЕМ

#____3______ метов popitem()- никакого параметра не принимает, а удаляет случайные значения из словаря, при этом возвращается удаленная пара ключ-значение
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
r=d.popitem()
print(r) # (4, [1, 2, 3])
print(d) # {1: 'one', 2: 'two', 3: 'three'}
# При попытке удалить с его помощью элемент из пустого словаря, мы получим ошибку - dictionary is empty -  словарь пуст

#____4______ метов keys() -  возвращает все значения ключей из словаря  в виде объекта типа dict_keys([1,2 ......]).
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
print(d.keys()) # dict_keys([1, 2, 3, 4])
# при использовании цикла for этого указано не было
for key in d:
    print(key,d[key])
#     1 one
#     2 two
#     3 three
#     4 [1, 2, 3] но подразумевалось, что мы использовали этот метод

for key in d.keys():
    print(key,d[key])
    # 1 one
    # 2 two
    # 3 three
    # 4 [1, 2, 3]

# ____5______ метов values() -  ничего не принимает, но возвращает значения словаря типа dict_values(['one', 'two', 'three', [1, 2, 3]])
print(d) # {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
print(d.values()) # dict_values(['one', 'two', 'three', [1, 2, 3]])
# После этого мы с помощью цикла for можем пройтись по значениям а не по ключам
for value in d.values():
    print(value)
    # one
    # two
    # three
    # [1, 2, 3]
#____6______ метов items() - возвращает коллекцию в которой содержатся все пары в виде картежей
print(d)# {1: 'one', 2: 'two', 3: 'three', 4: [1, 2, 3]}
print(d.items()) # dict_items([(1, 'one'), (2, 'two'), (3, 'three'), (4, [1, 2, 3])])
for item in d.items():
     print(item)
    # (1, 'one')
    # (2, 'two')
    # (3, 'three')
    # (4, [1, 2, 3])
# К ним тоже можно обращатся по индексу:
for item in d.items():
     print(item[0]) # Выведим тогда ключи
    # 1
    # 2
    # 3
    # 4

# или
for item in d.items():
     print(item[1]) # Выведим тогда значения
    # one
    # two
    # three
    # [1, 2, 3]

for item in d.items():
     print(item[0],item[1]) # выветит пару 
# #   1 one
#     2 two
#     3 three
#     4 [1, 2, 3]


# С использованием множественного присвоения в пайтоне можно поступить так
for key,value in d.items():
     print(key,value) # выветит пару 
    #  1 one
    # 2 two
    # 3 three
    # 4 [1, 2, 3]
